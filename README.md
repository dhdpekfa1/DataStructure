## 데이터 구조 (Data Structure)

데이터를 구성하고 저장하는 데 사용되는 저장소

-> 요구사항, 프로젝트에 따라 적합한 구조를 선택하는 것이 중요

### 선형 자료구조 (Linear Data Structure)

요소가 순차적으로 배열되어 있으며, 특정한 순서를 유지하는 것이 특징

- 배열(Array)
  - 요소들이 연속된 메모리 공간에 저장되며, 모든 요소는 동일한 데이터 타입을 가진다.
  - 장점: 인덱스를 통한 빠른 접근(O(1))
  - 단점: 크기 변경이 어렵고(O(n)) 삽입/삭제가 비효율적
- 스택(Stack)
  - 후입선출(LIFO, Last In First Out) 방식으로 동작
  - 예시: 박스 쌓기, 실행 취소(Undo), 웹 브라우저 뒤로 가기
  - 연산: push(삽입), pop(제거), peek(탑 요소 확인)
- 큐(Queue)
  - 선입선출(FIFO, First In First Out) 방식으로 동작
  - 예시: 맛집 대기열, 프린터 작업 큐
  - 연산: enqueue(삽입), dequeue(제거), front(첫 요소 확인)
- 연결 리스트(Linked List)
  - 요소(노드)들이 포인터(주소) 를 통해 연결된 형태
  - 배열과 차이점: 메모리 연속성이 필요 없고, 크기 조정이 용이
  - 종류: 단일 연결 리스트(Singly Linked List), 이중 연결 리스트(Doubly Linked List), 원형 연결 리스트(Circular Linked List)

### 비선형 자료구조

데이터가 순차적으로 배열되지 않고, 하나의 요소가 여러 개의 요소와 연결될 수 있는 계층적 구조

- 그래프(Graph)

  - 정점(Vertex)과 간선(Edge)으로 구성된 네트워크 구조
  - 예시: 지도 네비게이션, 소셜 네트워크

  1. 방향 그래프(Directed Graph): 간선에 방향이 존재 (ex: SNS 팔로우)
  2. 무방향 그래프(Undirected Graph): 간선에 방향이 없음 (ex: 친구 관계)

- 트리(Tree)
  - 부모-자식 관계를 가지는 계층적 자료구조로 사이클이 없고 한 노드는 하나의 부모만 가질 수 있다
  - 예시: 디렉터리 구조, 데이터베이스 인덱싱
  1. 이진 트리(Binary Tree): 각 노드가 최대 두 개의 자식을 가짐
  2. 이진 탐색 트리(BST, Binary Search Tree): 왼쪽 자식 < 부모 < 오른쪽 자식

---

| **선형 자료구조**                                                                                      | **비선형 자료구조**                                                                                           |
| ------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| 데이터 항목이 **순차적**으로 배열됨                                                                    | 데이터 항목이 **비순차적**, 계층적 또는 네트워크 구조로 배열됨                                                |
| 모든 데이터가 **단일 레이어**에 존재                                                                   | 데이터가 **다층 구조**를 가질 수 있음                                                                         |
| **단일 패스(횡단) 가능** → 첫 번째 요소부터 시작하면 순차적으로 모든 요소를 탐색 가능                  | **여러 번의 실행 필요** → 특정 구조(예: 그래프)에서는 단일 패스로 모든 요소를 탐색하기 어려울 수 있음         |
| **메모리 활용이 비효율적일 수 있음** → 연속된 공간이 필요하여, 크기 변경이 어려움(예: 배열)            | **메모리 활용이 유동적** → 동적 할당이 가능하고, 효율적으로 공간을 사용할 수 있음(예: 트리, 그래프)           |
| **데이터 크기에 따라 시간 복잡도 증가** → 탐색, 삽입, 삭제 연산이 크기에 따라 느려질 수 있음(예: O(n)) | **구조에 따라 시간 복잡도가 다름** → 트리, 그래프 등은 균형 유지 여부에 따라 O(log n) 또는 O(1)로 최적화 가능 |
